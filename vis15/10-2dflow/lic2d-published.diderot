#version 1.0
/*
As described in the README.md in this directory, lic2d.diderot is a more
informative example of how to implement LIC in Diderot, and that program has
some differences from what was published in Figure 8 of the VIS'15 paper.
Still, we can in fact use the published program (below) to make an
equivalent image, as follows:

# Match program's expectations of domain and range of field
unu unorient -i turb2d.nrrd |
unu axinfo -a 1 -mm 0 6.78 -sp nan |
unu axinfo -a 2 -mm 0 3.72 -sp nan |
unu 2op / - 4.6 |
unu dnorm -o flow.nrrd

# Make noise texture
unu slice -i flow.nrrd -a 0 -p 0 |
unu resample -s x2.7 x2.7 |
unu 1op nrand -s 42 -o rand.nrrd

# Make cmap.nrrd with vorticity bounds built in, via simple
# magenta-to-green lerping in RGB space (NOTE: over-writes cmap.nrrd
# generated by 1-dataprep.sh)
echo "0 1 0   1 1 1   1 0 1" |
unu reshape -s 3 3 |
unu resample -s = 300 -k tent -c node |
unu 2op pow - 1.5 |
unu axinfo -a 0 -k rgb |
unu axinfo -a 1 -mm -30 30 | # here are the vorticity bounds
unu dnorm -i - |
unu pad -min 0 -2 -max M M+2 -o cmap.nrrd

# compile
diderotc --target=pthread --exec lic2d-published.diderot

# run
./lic2d-published -sizeX 2058 -sizeY 1122 -h0 0.003 -stepNum 80

# post-process
unu project -i rgb.nrrd -a 1 -m mean |
unu resample -s = /1.5 /1.5 |
unu quantize -b 8 -min 0.1% -max 0.1% -o lic2d.png

# cleanup
rm -f flow.nrrd rand.nrrd cmap.nrrd rgb.nrrd
*/

// vvvvvvvvvvvvvvvvvvvvvv BEGIN program copied from Figure 8 of VIS'15 paper
input int sizeX;  input int sizeY; // LIC image size
input real h0;      // step size of integration
input int stepNum;  // steps taken up or downstream
real stdv = sqrt(1.0/stepNum);
field#1(2)[2] V = bspln3 ⊛ clamp(image("flow.nrrd"));
field#1(2)[2] nV = normalize(V);
field#0(2)[] R = tent ⊛ wrap(image("rand.nrrd"));
field#0(1)[3] cmap = tent ⊛ clamp(image("cmap.nrrd"));
strand LIC (vec2 x0, real sign) {
  real h = sign*h0;
  vec2 x = x0;
  int step = 0;
  real sum = R(x0)/2;  // initialize convolution sum
  output vec3 rgb = [0,0,0];
  update {
    x += h*nV(x + 0.5*h*nV(x)); // Midpoint method
    if (step == stepNum || !inside(x, V))
      stabilize;
    sum += R(x);
    step += 1;
  }
  stabilize {
    sum *= sqrt(|V(x0)|)/stepNum;
    rgb = cmap(∇×V(x0)) // colormap of vorticity
           * clamp(0,1, lerp(0,1, -stdv, sum, stdv));
  }
}
initially [ LIC([lerp(0, 6.78, -0.5, xi, sizeX-0.5),
                 lerp(0, 3.72, -0.5, yi, sizeY-0.5)],
                 lerp(-1, 1, 0, si, 1))
            | yi in 0..(sizeY-1), xi in 0..(sizeX-1),
              si in 0..1 ];
// ^^^^^^^^^^^^^^^^^^^^^^ END program copied from VIS'15 paper
